# Signing Parcels and Parcel Lists

This portion of the specification discusses the mechanics of signing parcel lists on invoices.

In the [Invoice](invoice-spec.md) specification, there are fields for attaching cryptographic signatures.
This specification describes the form and function of those fields.

> The term `Bindle` (uppercase) refers to the package storage system. The term `bindle` (lowercase) means a package in the Bindle system.

## Things NOT covered

- Key management. Here, we talk about using asymmetric cryptography to sign lists of parcels, but we do not discuss how the public and private keys are to be managed.
- Strengths and weaknesses of various signature algorithms. We supply here only a single Ed25519 implementation.

## The General Idea

The basic idea of signing significant items is that by attaching a signature, we can support tooling that has the ability to verify that certain facts about a bindle remain unchanged over time.

Specifically, we want assurances of two things:

1. That an invoice at a particular version has _exactly_ a particular set of parcels.
2. That each parcel has _exactly_ the content that the signer intended.

For example, by signing a parcel's hash, we can in effect certify that _an entity in possession of the signing key testifies that the parcel had this hash at the time in which the parcel was signed_. That is an important attestation when combined with a few other things (like key trust), because it provides a foundation for making assertions like this:

> Matt Butcher signed the hash for the parcel when he built it, and the hash hasn't changed. Therefore, the parcel is in the same condition it was when Matt Butcher built it.

Asymmetric cryptography is nice for this because a signer can distribute a public key and a signature, and that is enough information for someone to verify that the signature was generated by the signer's private key.

## Signing and Roles

Signers of an invoice MUST have a role. The following roles are defined by this specification.
Agents SHOULD initiate a warning and MAY initiate a failure if a user's expected role does not match the given role.

- `creator`: Signer asserts that they are the ones who made this bindle
- `approver`: Signer asserts that they have verified the contents of the bindle
- `proxy`: Signer asserts that they are a consumer or waypoint for this bindle, and have no reason to distrust the bindle
- `host`: Signer asserts that it has served as a Bindle host for this content

No invoice can be signed twice by the same key.
For example, a key cannot be used to sign both as `creator` and as `host`.
Nor are there any cases where a key is permitted to sign twice with the same role.

### The Creator Role

The `creator` signature MUST be on any invoice that is compliant with this system.
There MAY be multiple creators on an invoice.
A creator MUST NOT sign the same invoice with the same key multiple times.
The Bindle server MUST reject an invoice that is not signed by a creator.
(In other words, all bindles MUST be signed by a `creator` key before they can be hosted.)
When a new bindle is submitted, a Bindle server MUST reject an invoice that is signed by a creator's key for which the server does not have an entry in its keyring.
In other words, the server MUST have the keys for every creator whose Bindle it accepts to host.
A bindle server MUST NOT sign a bindle with its host key if it does not have the key of the creator in its keyring.
This does not necessarily preclude a "caching proxy", where the proxy is repeating a Bindle that has been signed by another set of creator and host keys.

> A _caching proxy_ is a Bindle server that takes a user's request for a bindle, finds that bindle remotely, and then caches that bindle's content locally so that it may re-serve that content at a later date. Such servers MAY sign with a proxy key.

A client SHOULD reject an invoice that is not signed by a known key with the `creator` or `approver` role. A non-normative recommendation would be that a client ought to reject any bindle where neither a creator's nor a approver's signature could be verified.

### The Approver Role

The `approver` role describes a signer who asserts that the signer has employed a method of assessing whether the bindle is correct.

Examples of approvers might include:

- A developer who reviews the code and build tools for the bindle's parcels
- A security scanner that runs an audit of the bindle and parcels
- A security researcher who performs a security audit and deems the bindle and parcels safe.

The `approver` role is specific to the security context. This signer is not deciding whether text content is editorially correct or that an image looks good. The signer is asserting that the security profile of the bindle is deemed trustworthy. That is, a vulnerability scanner is asserting, upon signature, that it detected no vulnerabilities in the bindle.

An underlying assumption of the present model is that keys with the `approver` role will be vetted more carefully before inclusion in the keyring.
End users in particular should be careful to only include well-known entities in their `approver` keyring.

Verification may form a trust proxy. That is, a client may decide that if the `creator` is unknown, the bindle can still be trusted if one or more of the `approver` keys is known.

### The Host role

The `host` role denotes that the signer is the Bindle server that accepted the invoice from the `creator`.

Bindle servers MUST add a `host` entry to a bindle upon receiving the bindle from a client and verifying the creator key.
A bindle server MUST NOT sign the same invoice more than once with the same key.
Clients MAY reject invoices that are signed by unknown hosts.

### The Proxy Role

Proxy signatures are designed for provenance more than security. When a non-creator pushes
a bindle to a Bindle server, the non-creator SHOULD sign the invoice with a proxy signature.

Examples of proxy signers:
- CI systems
- Users who transfer bindles from one Bindle server to another
- Import/export tools
- Proxy servers

While this is implicit in the definitions, we should make it _explicit_ that a Bindle server can use the same key to sign some invoices as a host (for bindles it hosts) and sign others as a proxy (for pass-through and cache features).
However, it cannot sign the same invoice with the same key acting as both a host and proxy.
In each case, the key must be marked for the appropriate role.

## Signing and Timestamps

The date and time of a signature can be an important piece of information for auditing.

Both invoice and parcel signatures require an `at` field with a UNIX timestamp expressed as an unsigned 64-bit integer with no leading zeros.

> Time stamps MUST be greater than 0. It is nonsensical to have a signature older than the the specification. For the sake of consistency, though, a 0 value is allowed in the formatting. However, implementations MAY reject any entries whose timestamps predate Sept. 1, 2020.

Since signature blocks are not primarily designed for human consumption, an implementation should prioritize simplicity and consistency over readability.
The UNIX timestamp offers this:

- It is well defined
- It is adopted broadly
- It is an unambiguous format that can easily be represented, serialized, and parsed
- It is accurate enough for the problem at hand

Longer textual formats are subject to parsing and serialization ambiguities, as well in quirks of implementation across languages.

## Signing on the Invoice

Signatures are included in the `invoice.toml` for a Bindle.

The signature does not need to sign the entire content of the invoice.
Rather, it needs to sign particular relationships.
For example, the list of parcels that belong to a bindle is both definitive and immutable.
As such, the list of parcel hashes should be signed to bind an exact parcel to a bindle.
Other pieces of information should also be signed, such as the name and version of a bindle.
The exhaustive list (and the format) are discussed below.

> To ensure that no other parts of an invoice have been modified, a host MAY take steps to verify the continued integrity of the `invoice.toml` and SHOULD encrypt all traffic between itself and clients.

Signatures on an `invoice` look like this:

```toml
bindleVersion = "v1.0.0"

[bindle]
name = "mybindle"
version = "0.1.0"
authors = ["Matt Butcher <matt.butcher@microsoft.com>"]
description = "My first bindle"

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "ddd237895ac..."
key = "1c44..."
role = "creator"
at = 1611960337

[[parcel]]
label.sha256 = "e1706ab0a39ac88094b6d54a3f5cdba41fe5a901"
label.mediaType = "text/html"
label.name = "myparcel.html"

[[parcel]]
label.sha256 = "098fa798779ac88094b6d54a3f5cdba41fe5a901"
label.name = "style.css"
label.mediaType = "text/css"

[[parcel]]
label.sha256 = "5b992e90b71d5fadab3cd3777230ef370df75f5b"
label.mediaType = "application/x-javascript"
label.name = "foo.js"
label.size = 248098
```

This format does not change with groups or conditions.

The signature is computed by concatenating the following pieces of data together in a line-separated (`\n`) UTF-8 string: `by`, `name`, `version`, `role`, `at` and the `label.sha256` of each parcel:

```
Matt Butcher <matt.butcher@example.com>
mybindle
0.1.0
creator
1611960337
~
e1706ab0a39ac88094b6d54a3f5cdba41fe5a901
098fa798779ac88094b6d54a3f5cdba41fe5a901
5b992e90b71d5fadab3cd3777230ef370df75f5b
```

Note that the sequence `\n~\n` is used as a separator to prevent an attempt to forge a hash using another field.

## Verifying

To verify, it is assumed that the client has access to a _keyring_ that contains one or more public keys.

Verification of an invoice includes the following steps:

1. Load the invoice
2. Extract the signature block from the invoice
3. Reconstruct the cleartext block following the signing rules
4. For each signature block
    a. Extract the public key
    b. Verify that the key has not already been used in another signature block
        - If a key is used to sign the same invoice multiple times, the implementation SHOULD fail
    c. Verify the signature using the public key and the cleartext
        - If verification fails for ANY signature block, fail
    d. Locate the key in the keyring
        - If the key is not located, this is not an error
5. Apply a key trust strategy (See "Strategies of Key Trust" below)
    - At minimum, the strategy should be that the `creator` signature is signed with a known key (Strategy 1).
    - For use on public bindle servers, allowing the `creator or approver` strategy (Strategy 2) is preferred.


## Keyrings

A keyring is an annotated list of (public) keys that can be used for verifying signatures in a bindle.

> A private key MUST NOT be stored in a keyring. Keyring data is considered non-secret (and thus a keyring could be checked into a VCS system or published on the Internet in some cases, and not as a result have integrity compromised).

The keyring format is expressed as TOML here:

```toml

[[key]]
label = "Matt Butcher <technosophos@example.com>"
roles = ["creator", "approver"]
key = "aa453q4..."
label_signature = "dsaff678..."

[[key]]
label = "Brigade pipeline at builder.example.com"
roles = ["proxy"]
key = "bb453q4..."
label_signature = "dsaff678..."

[[key]]
label = "https://bindle.example.com"
roles = ["host"]
key = "cc453q4..."
label_signature = "dsaff678..."
```

Fields on the `[[key]]` object:

- `label`: A human-readable label that hints what this key is for
- `roles`: A list of roles that the user has granted to the key
- `key`: The base64-encoded public key for this label
- `label_signature`: A signature block for the label, to assert that the label is the same one that was intended by the key creator (optional, may be removed)

## Reading Signatures as Provenance

```toml
# This identity asserts that it has created the bindle
[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "ddd237895ac..."
key = "1c44..."
role = "creator"
at = 1611960337

# This identity asserts that it has somehow proxied the bindle.
# In this case, it is a CI action that pushed the bindle to a host
[[signature]]
by = "GitHub Action [https://github.com/exammple.com/hello_repo]"
signature = "3dd237895ac..."
key = "3c44..."
role = "proxy"
at = 1611960347

# This identity asserts that it has hosted the bindle
[[signature]]
by = "Bindle Server [https://bindle.example.com]"
signature = "2dd237895ac..."
key = "2c44..."
role = "host"
at = 1611960357
```
 Because of the timestamps, we can reconstruct the timeline and see that the key was
 first signed by the creator, then signed by the proxy, and finally signed by the host.

## Strategies of Key Trust

This section is non-normative, describing how implementations MAY choose to behave.

A Bindle may be signed by any number of keys in any number of roles.
During verification, which of these keys must be verified?

The simplest configuration of Bindle would require that the `creator` key be present in the keyring, and the content is then verified against this key's signature. All other keys MAY be verified.

This section provides alternative trust strategies that allow different degrees of verification. Implementations may match their validation practices to the security needs of their environment.

Five strategies are discussed here. This is not an exhaustive set, but it illustrates the possibilities.

### Strategy 1: Creative Integrity

In this model, the `creator` signature is the only one we care about in verification. It is as if we are saying, "If the creator says the package I have is the right one, that is all the evidence I need."

### Strategy 2: Authoritative Integrity

This case might be considered weaker than the above, but it illustrates a different way to delegate according to which entity is considered the stronger authority.
In this case, we say that if the _creator or a approver_ assert that this package is correct, then we accept it.

This setup is useful for a few configurations:

*Public package repositories:* In this case, there may be tens of thousands of creators. But say that a designated entity could analyze the packages and determine their safety. In that case, a user agent might say "I will accept any package that has been signed by this trusted analyzer."

*Internal package repository:* In this case, an enterprise may make a stronger claim: "Whether you can use this package does not depend on whether the creator is trusted, but whether the package is marked as trusted by our internal approver."

### Strategy 3: Multiple Attestation

In this strategy, _at least two roles must be verified_.
The object of this configuration is double-checking for a compromise.

Here are a few scenarios for multiple attestation:

*Creator and CI Pipeline:* Ostensibly, a CI system will build the same package using the same tooling that the creator used.
Assuming the CI signs its artifacts with the `proxy` role,
one could require that both `creator` and `proxy` signatures must be present and be verified. This way, if the creator's system is compromised or misconfigured, this would show up in the form of a clash with the proxy signature. While it doesn't identify whether the proxy or the creator was compromised, it shows up as a clash between two distinct keys--and therefore serves as a signpost for where the problem may be.

*Creator and Host:* A similar pairing can be done between the creator role and the host role. In this case, comparing between the host and creator roles identifies any case where the package was compromised during or after upload to the server.

*Creator and approver:* This pairing is a step beyond the "Authoritative Integrity" section above, as it requires that both a creator and a approver can be verified. In other words, for a bindle to be verified, the creator has to certify that they created it, and the approver has to certify that the bindle has been audited.

From here, we could extrapolate to various other combinatorics (e.g. signer, host, and approver must all have verified signatures). But the core idea remains: a conjunction of verifications provides more security than a disjunction.

## Strategy 4: Greedy Verification

This model is the best default model. In it, there is an obligation to verify the `creator` signature, but verifying every other signature in the invoice SHOULD be attempted.

In this model:
- If the `creator` signature fails verification, the verification process should end with an error
- For each signature, its public key should be used to verify the signature. If this fails, the verification should end with an error.
- For each signature, its public key should be checked against the keyring. If the signature is missing, a warning should be emitted

The result is that every signature is partially tested, at least one must be fully tested, and any that cannot be fully tested are reported to the user.

(Bindle currently implements this strategy, but in the future, strategy will be configurable)

## Strategy 5: Complete Verification

In this strategy, _every signature on the invoice_ must be verified.

Therefore, if an invoice has ten signatures spread across all four roles, every single signature must be verified. Any unknown keys or mismatched signatures will cause failure.

This is a strong assertion that will lead to fragile process (virtuously, in some cases).
It is designed for cases where _every single step_ must be secured.
It will surface not just tampered packages, but also tampered process.
While not infallible, it can give an early and decisive warning if a package crossed the wrong security boundary.
For example, if a package is signed by an unknown host key, then this package has been hosted on a server outside the chain of trust.
While this level of scrutiny is not desirable on, say, a public Bindle registry, it may be invaluable to closed and air-gapped networks where the presence of an unknown signature may warn of a misconfiguration.


## Questions

### Why Don't You Just Hash The Document?

A: Because TOML (and most on-disk formats) can be expressed in ways that are subtly different. Whitespace, quotation marks, and other formatting changes can render the signature ineffective.

Instead of inventing another format or using something like Canonical JSON (with all its quirks), we took a semantic approach: What are the pieces of data that we actually need to protect, and can we handle just those?


