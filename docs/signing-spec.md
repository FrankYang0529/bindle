# Signing Parcels and Parcel Lists

This portion of the specification discusses the mechanics of signing parcel lists and individual parcels.

In the [Invoice](invoice-spec.md) and [Parcel](parcel-spec.md]) specifications, there are fields for attaching cryptographic signatures. In this specification, we cover the internal mechanics for how that works.

## Things NOT covered

- Key management. Here, we talk about using asymmetric cryptography to sign parcels and lists of parcels, but we do not discuss how the public and private keys are to be managed.
- Strengths and weaknesses of various signature algorithms. We supply here only a single Ed25519 implementation.

## The General Idea

The basic idea of signing significant items is that by attaching a signature, we can provide tooling the ability to verify that certain facts about a bindle remain unchanged over time.

For example, by signing a parcel's hash, we can in effect certify that _an entity in possession of the signing key testifies that the parcel had this hash at the time in which the parcel was signed_. That is an important attestation when combined with a few other things (like key trust), because it provides a foundation for making assertions like this:

> Matt Butcher signed the hash for the parcel when he built it, and the hash hasn't changed. Therefore, the parcel is in the same condition it was when Matt Butcher built it.

Asymmetric cryptography is nice for this because a signer can distribute a public key and a signature, and that is enough information for someone to verify that the signature was generated by the signer's private key.

## Signing and Roles

Signers of an invoice MUST have a role. The following roles are defined by this specification.
Agents SHOULD initiate a warning and MAY initiate a failure if another role is encountered.

- `creator`: Signer asserts that they are the ones who made this bindle
- `proxy`: Signer asserts that they are a consumer or waypoint for this bindle, and have no reason to distrust
- `host`: Signer asserts that it has served as a Bindle host for this content

The `creator` signature MUST be on any invoice that is compliant with this system.
There MAY be multiple creators on an invoice.
A creator MUST NOT sign the same invoice with the same key multiple times.
A Bindle server MUST reject an invoice that is not signed by a creator.
A Bindle server MUST reject an invoice that is signed by a creator's key for which the server does not have an entry in its keyring.
A client SHOULD reject an invoice signed by a creator whose public key is not in the client's keyring

Bindle servers MUST add a `host` entry to a bindle upon receiving the bindle from a client.
A bindle server MUST NOT sign the same invoice more than once with the same key.
Clients MAY reject invoices that are signed by unknown hosts, but they also MAY allow them.

Proxy signatures are designed for provenance more than security. When a non-creator pushes
a bindle to a Bindle server, the non-creator SHOULD sign the invoice with a proxy signature.

Examples of proxy signers:
- CI systems
- Users who transfer bindles from one Bindle server to another
- Import/export tools

## Signing and Timestamps

The date and time of a signature can be an important piece of information for auditing.

Both invoice and parcel signatures require an `at` field with a UNIX timestamp expressed as an unsigned 64-bit integer with no leading zeros.

> Time stamps MUST be greater than 0. It is nonsensical to have a signature older than the the specification. For the sake of consistency, though, a 0 value is allowed in the formatting. However, implementations MAY reject any entries whose timestamps predate Sept. 1, 2020.

Since signature blocks are not primarily designed for human consumption, an implementation should prioritize simplicity and consistency over readability.
The UNIX timestamp offers this:

- It is well defined
- It is adopted broadly
- It is an unambiguous format that can easily be represented, serialized, and parsed
- It is accurate enough for the problem at hand

Longer textual formats are subject to parsing and serialization ambiguities, as well in quirks of implementation across languages.

## Signing Parcels

The main piece of information we want to sign in a parcel is the data-bearing `parcel.dat` data. More specifically, all we really need to sign is the SHA for that bundle.

Since the signature cannot be forged without either key compromise or failure of the underlying encryption, we can assert that the signature data can be placed inside of the parcel's `label` without jeopardizing the integrity of the data.

To sign a parcel, we need the following bits of information:

- The parcel data's SHA
- A public/private key pair
- A name for the key pair (`by`) to be used as a heuristic for the user
- A UNIX timestamp (`at`)

Assume for a moment that we can generate a signature of the parcel data. Given this, we can insert a signature into the label as follows.

```toml
sha256 = 5b992e90b71d5fadab3cd3777230ef370df75f5b...
mediaType = "application/x-javascript"
name = "foo.js"
size = 248098

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "baa237895ac..."
role = "creator"
at = 1611960337
```

In fact, the public key can be distributed inline provided that the client takes steps to determine whether that key is known and trusted.

```toml
sha256 = 5b992e90b71d5fadab3cd3777230ef370df75f5b...
mediaType = "application/x-javascript"
name = "foo.js"
size = 248098

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "baa237895ac..."
key = "95ac..."
role = "creator"
at = 1611960337
```

Note that the `signature` is a list, not a table. This is so that multiple attestations can be made about the same object:

```toml
sha256 = 5b992e90b71d5fadab3cd3777230ef370df75f5b...
mediaType = "application/x-javascript"
name = "foo.js"
size = 248098

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "baa237895ac..."
key = "95ac..."
role = "creator"
at = 1611960337

[[signature]]
by = "Radu Matei <radu.matei@example.com>"
signature = "aba237895ac..."
key = "ac95..."
role = "creator"
at = 1611960338
```

To compose the signature, the following data should be combined into a `\n`-separated UTF-8 encoded string and hashed: `by`, `role`, `at` and the `sha256`

```
Radu Matei <radu.matei@example.com>
creator
1611960338
~
5b992e90b71d5fadab3cd3777230ef370df75f5b...
```

The `by` field is included to prevent a trivial (and probably not critical) deception in which an attacker changes the `by` line to something that sounds authoritative in hopes that a user blindly accepts. But this is a very minor edge case.

The above can then be signed with something like `base64(sign($key, $data))`

## Signing the Invoice

In an invoice, what we want to sign is the list of parcels attached to the invoice. In other words, what we really care about is ensuring that the invoice's parcel list has not been changed since it was last signed.

This strategy hinges on the assumption that no malevolent alterations can be made to a bindle outside of its parcels.

Signatures on an `invoice` look like this:

```toml
bindleVersion = "v1.0.0"

[bindle]
name = "mybindle"
version = "0.1.0"
authors = ["Matt Butcher <matt.butcher@microsoft.com>"]
description = "My first bindle"

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "ddd237895ac..."
key = "1c44..."
role = "creator"
at = 1611960337

[[parcel]]
label.sha256 = "e1706ab0a39ac88094b6d54a3f5cdba41fe5a901"
label.mediaType = "text/html"
label.name = "myparcel.html"

[[parcel]]
label.sha256 = "098fa798779ac88094b6d54a3f5cdba41fe5a901"
label.name = "style.css"
label.mediaType = "text/css"

[[parcel]]
label.sha256 = "5b992e90b71d5fadab3cd3777230ef370df75f5b"
label.mediaType = "application/x-javascript"
label.name = "foo.js"
label.size = 248098
```

This format does not change with groups or conditions.

The signature is computed by concatenating the following pieces of data together in a line-separated (`\n`) UTF-8 string: `by`, `name`, `version`, `role`, `at` and the `label.sha256` of each parcel:

```
Matt Butcher <matt.butcher@example.com>
mybindle
0.1.0
creator
1611960337
~
e1706ab0a39ac88094b6d54a3f5cdba41fe5a901
098fa798779ac88094b6d54a3f5cdba41fe5a901
5b992e90b71d5fadab3cd3777230ef370df75f5b
```

Note that the sequence `\n~\n` is used as a separator to prevent an attempt to conflate a 
SemVer with the SHA list.

## Verifying

To verify, it is assumed that the client has access to a _keyring_ that contains one or more public keys.

Verification of an invoice includes the following steps:

1. Load the invoice
2. Extract the signature block from the invoice
3. Reconstruct the cleartext block following the signing rules
4. For each signature block
    a. Extract the public key
    b. Verify the signature using the public key and the cleartext
        - If verification fails for ANY signature block, fail
    c. Locate the key in the keyring
        - If the key is not located, this is not an error
5. Verify that at least one signature block used a key that was present in the keyring (4.c)
    - If none of the signatures were done with a key we know, fail

## Reading Signatures as Provenance

```toml
# This identity asserts that it has created the bindle
[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "ddd237895ac..."
key = "1c44..."
role = "creator"
at = 1611960337

# This identity asserts that it has somehow proxied the bindle.
# In this case, it is a CI action that pushed the bindle to a host
[[signature]]
by = "GitHub Action [https://github.com/exammple.com/hello_repo]"
signature = "3dd237895ac..."
key = "3c44..."
role = "proxy"

# This identity asserts that it has hosted the bindle
[[signature]]
by = "Bindle Server [https://bindle.example.com]"
signature = "2dd237895ac..."
key = "2c44..."
role = "host"
```

## Questions

### Why Don't You Just Hash The Document?

A: Because TOML (and most on-disk formats) can be expressed in ways that are subtly different. Whitespace, quotation marks, and other formatting changes can render the signature ineffective.

Instead of inventing another format or using something like Canonical JSON (with all its quirks), we took a semantic approach: What are the pieces of data that we actually need to protect, and can we handle just those?

