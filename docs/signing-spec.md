# Signing Parcels and Parcel Lists

This portion of the specification discusses the mechanics of signing parcel lists and individual parcels.

In the [Invoice](invoice-spec.md) and [Parcel](parcel-spec.md]) specifications, there are fields for attaching cryptographic signatures. In this specification, we cover the internal mechanics for how that works.

## Things NOT covered

- Key management. Here, we talk about using asymmetric cryptography to sign parcels and lists of parcels, but we do not discuss how the public and private keys are to be managed.
- Strengths and weaknesses of various signature algorithms. We supply here only a single Ed25519 implementation.

## The General Idea

The basic idea of signing significant items is that by attaching a signature, we can provide tooling the ability to verify that certain facts about a bindle remain unchanged over time.

For example, by signing a parcel's hash, we can in effect certify that _an entity in possession of the signing key testifies that the parcel had this hash at the time in which the parcel was signed_. That is an important attestation when combined with a few other things (like key trust), because it provides a foundation for making assertions like this:

> Matt Butcher signed the hash for the parcel when he built it, and the hash hasn't changed. Therefore, the parcel is in the same condition it was when Matt Butcher built it.

Asymmetric cryptography is nice for this because a signer can distribute a public key and a signature, and that is enough information for someone to verify that the signature was generated by the signer's private key.

## Signing Parcels

The main piece of information we want to sign in a parcel is the data-bearing `parcel.dat` data. More specifically, all we really need to sign is the SHA for that bundle.

Since the signature cannot be forged without either key compromise or failure of the underlying encryption, we can assert that the signature data can be placed inside of the parcel's `label` without jeopardizing the integrity of the data.

To sign a parcel, we need the following bits of information:

- The parcel data's SHA
- A public/private key pair
- A name for the key pair (`by`) to be used as a heuristic for the user

Assume for a moment that we can generate a signature of the parcel data. Given this, we can insert a signature into the label as follows.

```toml
sha256 = 5b992e90b71d5fadab3cd3777230ef370df75f5b...
mediaType = "application/x-javascript"
name = "foo.js"
size = 248098

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "baa237895ac..."
```

In fact, the public key can be distributed inline provided that the client takes steps to determine whether that key is known and trusted.

```toml
sha256 = 5b992e90b71d5fadab3cd3777230ef370df75f5b...
mediaType = "application/x-javascript"
name = "foo.js"
size = 248098

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "baa237895ac..."
key = "95ac..."
```

Note that the `signature` is a list, not a table. This is so that multiple attestations can be made about the same object:

```toml
sha256 = 5b992e90b71d5fadab3cd3777230ef370df75f5b...
mediaType = "application/x-javascript"
name = "foo.js"
size = 248098

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "baa237895ac..."
key = "95ac..."

[[signature]]
by = "Radu Matei <radu.matei@example.com>"
signature = "aba237895ac..."
key = "ac95..."
```

To compose the signature, the following data should be combined into a `\n`-separated UTF-8 encoded string and hashed: `by` and the `sha256`

```
Radu Matei <radu.matei@example.com>
5b992e90b71d5fadab3cd3777230ef370df75f5b...
```

The `by` field is included to prevent a trivial (and probably not critical) deception in which an attacker changes the `by` line to something that sounds authoritative in hopes that a user blindly accepts. But this is a very minor edge case.

The above can then be signed with something like `base64(sign($key, $data))`

## Signing the Invoice

In an invoice, what we want to sign is the list of parcels attached to the invoice. In other words, what we really care about is ensuring that the invoice's parcel list has not been changed since it was last signed.

This strategy hinges on the assumption that no malevolent alterations can be made to a bindle outside of its parcels.

Signatures on an `invoice` look like this:

```toml
bindleVersion = "v1.0.0"

[bindle]
name = "mybindle"
version = "0.1.0"
authors = ["Matt Butcher <matt.butcher@microsoft.com>"]
description = "My first bindle"

[[signature]]
by = "Matt Butcher <matt.butcher@example.com>"
signature = "ddd237895ac..."
key = "1c44..."

[[parcel]]
label.sha256 = "e1706ab0a39ac88094b6d54a3f5cdba41fe5a901"
label.mediaType = "text/html"
label.name = "myparcel.html"

[[parcel]]
label.sha256 = "098fa798779ac88094b6d54a3f5cdba41fe5a901"
label.name = "style.css"
label.mediaType = "text/css"

[[parcel]]
label.sha256 = "5b992e90b71d5fadab3cd3777230ef370df75f5b"
label.mediaType = "application/x-javascript"
label.name = "foo.js"
label.size = 248098
```

This format does not change with groups or conditions.

The signature is computed by concatenating the following pieces of data together in a line-separated (`\n`) UTF-8 string: `by`, `name`, `version`, and the `label.sha256` of each parcel:

```
Matt Butcher <matt.butcher@example.com>
mybindle
0.1.0
e1706ab0a39ac88094b6d54a3f5cdba41fe5a901
098fa798779ac88094b6d54a3f5cdba41fe5a901
5b992e90b71d5fadab3cd3777230ef370df75f5b
```


## Questions

### Why Don't You Just Hash The Document?

A: Because TOML (and most on-disk formats) can be expressed in ways that are subtly different. Whitespace, quotation marks, and other formatting changes can render the signature ineffective.

Instead of inventing another format or using something like Canonical JSON (with all its quirks), we took a semantic approach: What are the pieces of data that we actually need to protect, and can we handle just those?

